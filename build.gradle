import net.darkhax.curseforgegradle.TaskPublishCurseForge

plugins {
    id 'java-library'
    id 'maven-publish'
    id 'net.neoforged.moddev' version '2.0.113'
    id 'idea'
    id 'com.modrinth.minotaur' version '2.+'
    id 'net.darkhax.curseforgegradle' version '1.1.26'
    id 'com.diffplug.spotless' version '6.25.0'
}

apply from: "$rootDir/gradle/dependencies.gradle"
apply from: "$rootDir/gradle/changelogs.gradle"
apply from: "$rootDir/gradle/publishing.gradle"
apply from: "$rootDir/gradle/building.gradle"
apply from: "$rootDir/gradle/initialization.gradle"
apply from: "$rootDir/gradle/debugging.gradle"

// ========================================
// PROJECT CONFIGURATION
// ========================================

version = "${mod_version}"
group = "${mod_group_id}"

base {
    archivesName = "${mod_id}"
}

java.toolchain.languageVersion = JavaLanguageVersion.of(java_version)

// ========================================
// GRADLE WRAPPER CONFIGURATION
// ========================================

tasks.named('wrapper', Wrapper).configure {
    distributionType = Wrapper.DistributionType.BIN
}

// ========================================
// NEOFORGE CONFIGURATION
// ========================================

neoForge {
    version = project.neo_version

    parchment {
        mappingsVersion = project.parchment_mappings_version
        minecraftVersion = project.parchment_minecraft_version
    }

    // This line is optional. Access Transformers are automatically detected
    // accessTransformers = project.files('src/main/resources/META-INF/accesstransformer.cfg')

    runs {
        client {
            client()
            // Comma-separated list of namespaces to load gametests from. Empty = all namespaces.
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        server {
            server()
            programArgument '--nogui'
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        gameTestServer {
            // This run config launches GameTestServer and runs all registered gametests, then exits.
            // By default, the server will crash when no gametests are provided.
            // The gametest system is also enabled by default for other run configs under the /test command.
            type = "gameTestServer"
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        data {
            clientData()
            // example of overriding the workingDirectory set in configureEach above, uncomment if you want to use it
            // gameDirectory = project.file('run-data')

            // Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
            programArguments.addAll '--mod', project.mod_id, '--all',
                    '--output', file('src/generated/resources/').getAbsolutePath(),
                    '--existing', file('src/main/resources/').getAbsolutePath()
        }

        // applies to all the run configs above
        configureEach {
            // Recommended logging data for a userdev environment
            // The markers can be added/remove as needed separated by commas.
            // "SCAN": For mods scan.
            // "REGISTRIES": For firing of registry events.
            // "REGISTRYDUMP": For getting the contents of all registries.
            systemProperty 'forge.logging.markers', 'REGISTRIES'
            logLevel = org.slf4j.event.Level.DEBUG
        }
    }

    mods {
        // define mod <-> source bindings
        // these are used to tell the game which sources are for which mod
        // multi mod projects should define one per mod
        "${mod_id}" {
            sourceSet(sourceSets.main)
        }
    }
}

// ========================================
// SOURCE SETS & DEPENDENCIES
// ========================================

// Include resources generated by data generators.
sourceSets.main.resources {
    srcDir 'src/generated/resources'
}

// Sets up a dependency configuration called 'localRuntime'.
// This configuration should be used instead of 'runtimeOnly' to declare
// a dependency that will be present for runtime testing but that is
// "optional", meaning it will not be pulled by dependents of this mod.
configurations {
    runtimeClasspath.extendsFrom localRuntime
}


// ========================================
// MOD METADATA GENERATION
// ========================================
var generateModMetadata = tasks.register("generateModMetadata", ProcessResources) {
    var replaceProperties = [
            minecraft_version      : minecraft_version,
            minecraft_version_range: minecraft_version_range,
            neo_version            : neo_version,
            neo_version_range      : neo_version_range,
            magmacore_version_range: magmacore_version_range,
            loader_version_range   : loader_version_range,
            pack_format_number     : pack_format_number,
            mod_id                 : mod_id,
            mod_name               : mod_name,
            mod_license            : mod_license,
            mod_version            : mod_version,
            mod_authors            : mod_authors
    ]
    inputs.properties replaceProperties
    expand replaceProperties
    from "src/main/templates"
    into "build/generated/sources/modMetadata"
}

sourceSets.main.resources.srcDir generateModMetadata
neoForge.ideSyncTask generateModMetadata

// ========================================
// BUILD & FORMATTING
// ========================================

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

// ========================================
// IDE CONFIGURATION
// ========================================

idea {
    module {
        downloadSources = true
        downloadJavadoc = true
    }
}


// ========================================
// MAVEN PUBLISHING
// ========================================

publishing {
    publications {
        register('mavenJava', MavenPublication) {
            from components.java

            groupId = project.group
            artifactId = project.base.archivesName.get()
            version = project.version

            pom {
                name = mod_name
                description = "${mod_name} - Minecraft mod"

                licenses {
                    license {
                        name = mod_license
                    }
                }

                developers {
                    developer {
                        name = mod_authors
                    }
                }
            }
        }
    }
    repositories {
        maven {
            url "file://${project.projectDir}/repo"
        }
    }
}


// ========================================
// PLATFORM PUBLISHING
// ========================================

// Modrinth Configuration
def rawGameVersions = project.findProperty("game_versions")?.toString() ?: ""
def parsedGameVersions = rawGameVersions.split(",").collect { it.trim() }

afterEvaluate {
    modrinth {
        token = System.getenv("MODRINTH_TOKEN") ?: project.findProperty("modrinthToken")?.toString()
        projectId = mr_id
        versionName = "v.${mod_version}-${mod_loader}"
        versionNumber = "v.${mod_version}"
        versionType = release_type
        uploadFile = jar
        loaders = ["neoforge"]
        gameVersions = parsedGameVersions
        changelog = readLatestChangelog()
        failSilently = true
        syncBodyFrom = rootProject.file("README.md").text
        dependencies {
            // The scope can be `required`, `optional`, `incompatible`, or `embedded`
            // The type can either be `project` or `version`
            required.project "magma-core"
            optional.project "antique-atlas"
        }
    }
}


// CurseForge Configuration
tasks.register('publishCurseForge', TaskPublishCurseForge) {
    def tokens = validateTokens()
    apiToken = tokens[1] // CurseForge token

    def mainFile = upload(project.findProperty("cf_id") as Integer, jar)
    mainFile.displayName = "${mod_name.replace(' ', '')} v.${mod_version}-${mod_loader}"
    mainFile.releaseType = release_type
    mainFile.changelog = readLatestChangelog()
    mainFile.changelogType = 'markdown'
    mainFile.addModLoader('NeoForge')
    mainFile.addJavaVersion("Java ${java_version}")
    parsedGameVersions.each { version ->
        mainFile.addGameVersion(version)
    }
    mainFile.addEnvironment()
    environment_type.split(',').each { env ->
        mainFile.addEnvironment(env.trim())
    }
}


// Changelog reading
    String readLatestChangelog() {
        //1. from workspace
        def file = rootProject.file("LATEST_CHANGELOG.md")
        if (file.exists()) {
            try {
                def text = file.getText('UTF-8').trim()
                if (text) {
                    logger.lifecycle("Using changelog from file: ${file}")
                    return text
                } else {
                    logger.lifecycle("LATEST_CHANGELOG.md exists but is empty.")
                }
            } catch (Exception e) {
                logger.warn("Error from reading LATEST_CHANGELOG.md: ${e.message}")
            }
        } else {
            logger.lifecycle("LATEST_CHANGELOG.md not found in project root.")
        }

        //2. from Git-HEAD
        try {
            ByteArrayOutputStream stdout = new ByteArrayOutputStream()
            exec {
                commandLine 'git', 'show', 'HEAD:LATEST_CHANGELOG.md'
                standardOutput = stdout
                // don't fail build if git command fails
                ignoreExitValue = true
            }
            def gitText = stdout.toString('UTF-8').trim()
            if (gitText) {
                logger.lifecycle("Using changelog from git HEAD:LATEST_CHANGELOG.md")
                return gitText
            } else {
                logger.lifecycle("No LATEST_CHANGELOG.md content found at git HEAD.")
            }
        } catch (Exception e) {
            logger.warn("Error from executing 'git show': ${e.message}")
        }

        // 3. fallback
        try {
            def generated = generateLatestChangelog()
            logger.lifecycle("Using generated changelog (fallback).")
            return generated
        } catch (Exception e) {
            logger.warn("generateLatestChangelog() failed: ${e.message}")
        }

        logger.lifecycle("No changelog found â€” returning empty string.")
        return ""
    }
